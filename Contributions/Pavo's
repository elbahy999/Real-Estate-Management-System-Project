//PAVO's code Main DCLL: A DCLL<Neighborhood> stores all unique neighborhood names within the system.
This serves as the primary index.Neighborhood Object: Each Neighborhood node contains a sub-DCLL, specifically a DCLL<Property>, 
which holds all the properties located in that specific area.Statistical Data: The Neighborhood class also tracks essential statistical data,
including the propertyCount and totalValue (sum of prices) to allow for $O(1)$ retrieval of the average property price within that neighborhood. 
template <typename T>
struct NeighborhoodNode {
    T data;
    NeighborhoodNode<T>* next;
    NeighborhoodNode<T>* prev;

    NeighborhoodNode(const T& neighborhood) : data(neighborhood), next(nullptr), prev(nullptr) {}
};
class Neighborhood {
private:
    string name;
    int propertyCount;
    double totalValue;
    vector<int> propertyIDs;
    DCLL<Property>* properties;
public:
    Neighborhood(const string& neighborhoodName)
        : name(neighborhoodName), propertyCount(0), totalValue(0.0) {}
    //getter 
    const string& getname()const { return name; }
    int getPropertyCount()const { return propertyCount; }
    double getAvergePrice()const { return (propertyCount == 0) ? 0.0 }
    DCLL <Property> getProperties()const { return properties; }
    void addproperty(const Property&p) {
        properties.insert(p);
        totalValue += p.getPrice();
        propertyCount++;
        cout << p.getPropertyID();
    }
    void removeProperty(int propertyID) {
        Property* proptoremove = properties->search(propertyID);
        double pricetoremove = proptoremove->getPrice();
        properties->remove(propertyID);
        totalValue -= pricetoremove;
        propertyCount--;
        cout << propertyID;
    }  
    int search(NeighborhoodNode* head, int id) {
        NeighborhoodNode* current = head;
        int position = 0;
        while (current != nullptr && current->data != x) {
            position++;
            current = current->next;                        
            if (current == nullptr)
            {
                return false;
            }
            else {
                return (pos + 1);
            }
        }
    }
    template <typename T>
    class NeighborhoodIndex {
    private:
        DCLL<Neighborhood>index; 
        Neighborhood* <T> findNeighborhood(const string& name) {
            if (index.getCount() == 0) {
                return nullptr;
            }PropertyNode<Neighborhood>* current = index.tail->next;
            do {
                if (current->data.getName() == name)
                {
                    return current->data;
                }
                current = current->next;
            }while ( current != index.tail->next){
                return nullptr;
        }
    public:
        void insertNeighborhood(const string& name) {
            if (findNeighborhood(name) == null) {
                Neighborhood newN(name);
                index.insert(newN);
            }
        }
        }
        void addPropN(const Propert& p) {
            Neighborhood<T>* n = findNeighborhood(p.getneighborhoodName());
                if(n == nullptr)
                {
                    insertNeighborhood(p.getneighborhoodName());
                    n = findNeighborhood(p.getneighborhoodName())
                }
        }  n->addproperty(p);
    };
    void removepropfromNeighborhood(int propertyID,const string& neighborhoodName) {
        Neighborhood<T>* n = findNeighborhood(neighborhoodName());
        if (n == nullptr) {
            throw runtime_error(" No neighborhood found");
        } n->removeProperty(propertyID);
    }
};

        
